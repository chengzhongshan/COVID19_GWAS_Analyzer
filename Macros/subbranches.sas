%macro subbranches(
    data=,           /* input dataset, which should
	contain the following 3 input vars:*/
	y_name_var=y_name_,
	y_parent_var=y_parent_,
	y_height_var=y_height_,
    out=work.sub,    /* output dataset */
    height=,         /* numeric cutoff (use either height= or parent=), and only the 
	the branche with the most closest height to the cutoff along with its sub-braches
	will be captured by the macro! So it is important to select the right cutoff
	for your target braches; it is possible to get the branche corresponding to 
	the height cutoff by printing out the final output data to check the 
	correponding branche matched with the hight cutoff;*/
    parent=,         /* list of parent ids (space or comma separated), e.g. CL2 CL3 */
    render=NO       /* YES/NO to call PROC SGRENDER with template */
    );

    /* validate dataset exists */
    %if %sysevalf(%superq(data)=,boolean) %then %do;
        %put ERROR: data= is required.;
        %return;
    %end;
    %if %sysfunc(exist(&data)) = 0 %then %do;
        %put ERROR: Dataset &data does not exist.;
        %return;
    %end;

	data _x_;
	length y_name_ y_parent_ $1000.;
	set &data;
	&y_name_var=&y_name_var;
	&y_parent_var=&y_parent_var;
	&y_height_var=&y_height_var;
	where &y_name_var^="";
	keep &y_name_var &y_parent_var &y_height_var;
	run;

    /* prepare initial seed set "keep0" (use robust existence checks) */
    %if %length(%superq(height)) %then %do;
       %let height_cutoff=&height;
    %end;
    %else %if %length(%superq(parent)) %then %do;
       proc sql noprint;
	   select &y_height_var into: height_cutoff
	   from _x_
	   where &y_name_var="&parent";
	   *This method is prune to error when there are other clusters that have equal height to the target cluster;
	   *Make sure the filter is set as height < but not <= height_cutoff around line 59 in this script;
	   *However, these codes are necessary to get the right height for the target parent;

	   *Better method for get the right parents and leaves under the target parent  is implemented as follows:;
	   %treeorder(
data=_x_, 	/*A typical output generated by proc cluster*/
child=&y_name_var,  /*Equivalent to y_name_ or x_name_ from proc cluster; ensure there is not spaces
included in the elements of this variable!*/
parent=&y_parent_var, /*Equivalent to y_parent_ or x_parent_ from proc cluster*/ 
hh=&y_height_var, /*Equivalent to y_height_ or x_height_ from proc cluster*/
root=&parent, /*the toppest root cluster name, and all braches under it will be searched for leaves*/
order=ASC, /*Any non-string would be OK, as if provided with the string NAME, the input data
will be sorted by parent and child names, however, SAS generted tree data set is used by 
proc tree or the statement of dendrogram in proc template to draw tree by sorting 
with the modified parent by using numers to represnet them, 
child and height, so please just use default string ASC for SAS generated input data*/ 
outds=_leaf_order_, /*An output data set containing ordered leaf names from left to right in the dendrogram
if running with SAS to generate tree using the input data*/
parent_ds=_parent_list_ /*An output data set contain all parents and its childrens*/
     );
/*	 %abort 255;*/
	   proc sql noprint;
	   create table _x_ as 
	   select a.* 
	   from _x_ as a,
	           _parent_list_ as b
	   where a.&y_parent_var=b.name;
/*	   select max(&y_height_var) into: height_cutoff*/
/*	   from _x_*/
/*	   where &y_parent_var="&parent"*/
/*       group by &y_parent_var; */
*The above codes does not get the right height for the parent;
	   data _x_;
	   set _x_ end=eof;
	   if eof then do;
	        output;
	       *Manually add a record for the target parent for the child column: &y_name_var;
	       &y_name_var="&parent";&y_height_var=&height_cutoff; &y_parent_var="";
		   output;
	   end;
	   else do;
	      output;
	   end;
	   run;
	   *Note the addition of 0.0001 to the max height will enable the use of < but not <= later to filter these parents;
	   *It is not necessary but just for uniforming the codes with that for filtering the dataset soly by height when the;
	   *macro parent is empty but the macro height is provided with a numeric value;
    %end;
    %else %do;
        %put ERROR: Either height= or parent= must be provided.;
        %return;
    %end;

proc sql noprint;
create table _x_1 as 
select a.*
from _x_ as a
where a.&y_height_var<=&height_cutoff;
/*%abort 255;*/
proc sql noprint;
select max(&y_height_var)  into: max_height
from _x_1;
select &y_name_var into: parent 
from _x_1
having &y_height_var=max(&y_height_var);
create table _x_2 as
select a.*
from _x_1 as a
where a.&y_parent_var in (
  select &y_name_var
  from _x_1
);
create table _x_tag as
select &y_parent_var,input(prxchange("s/CL//",-1,&y_parent_var),best12.) as ord
from _x_2
order by ord;

data _x_tag;
retain n 0;
set _x_tag;
if first.ord then n=n+1;
new_&y_parent_var=cat('CL',n);
by ord;
run; 

proc sql;
create table _x_3 as
select a.*,b.new_&y_parent_var as new_&y_parent_var.1
from _x_2 as a
left join
_x_tag as b
on a.&y_parent_var=b.&y_parent_var;
create table _x_3 as
select distinct a.*,b.new_&y_parent_var as new_&y_name_var.1
from _x_3 as a
left join
_x_tag as b
on a.&y_name_var=b.&y_parent_var;
data _x_3;
set _x_3;
*Keep these original name for later looking up;
old_&y_name_var=&y_name_var;
old_&y_parent_var=&y_parent_var;
run;
data _x_3;
set _x_3;
if new_&y_name_var.1^="" then &y_name_var=new_&y_name_var.1;
&y_parent_var=new_&y_parent_var.1;
run;
data _x_3_;
&y_parent_var="";
&y_name_var="CL1";
&y_height_var=&max_height;
run;
data _x_3;
set _x_3 _x_3_;
drop new_y_:;
run;

proc sql;
create table &out as
select a.*
from _x_3 as a
where a.&y_parent_var in (
  select &y_name_var 
  from _x_3
) or a.&y_parent_var="";
data &out;
set &out;
if &y_name_var="CL1" and &y_parent_var="" then old_&y_name_var="&parent";
/* optional render */
%if %upcase(&render) = YES %then %do;
proc template;
   define statgraph HeatDendrogram1;
/*      begingraph / designheight=&height.cm designwidth=&width.cm;*/
    begingraph;
            layout overlay / 
/*xaxisopts=(display=none) yaxisopts=(display=none)*/
                             walldisplay=none;
               dendrogram nodeID=&y_name_var parentID=&y_parent_var clusterheight=&y_height_var;
			 endlayout;
	endgraph;
end;
run;	
*To recapture the original cluster, need to sort the data by numeric parent, child, and height;
*the order of which is used by proc template to draw dendrogram;
data &out;set &out;ord=prxchange("s/^CL//",-1,&y_parent_var)+0;
proc sort data=&out;by descending ord &y_name_var &y_height_var; 
data &out;set &out;drop ord;run;
proc sgrender data=&out template=HeatDendrogram1;
run;
%end;

%mend subbranches;
/*Demo codes:;
data x;
input y_name_ :$25. y_parent_ :$3. y_height_;
cards;
NG_MYH11__CBFB	CL7	0
NTU_MYH11__CBFB	CL7	0
NG_KMT2Ar	CL6	0
NTU_KMT2Ar	CL6	0
NG_APL	CL5	0
NTU_APL	CL5	0
NG_RUNX1__RUNX1T1	CL4	0
NTU_RUNX1__RUNX1T1	CL4	0
CL5	CL3	0.48486
CL6	CL3	0.36378
CL3	CL2	0.90933
CL4	CL2	0.50744
CL2	CL1	0.92
CL7	CL1	0.25102
CL1	 .	1.60468
;

*begingraph / designheight=&height.cm designwidth=&width.cm;
*xaxisopts=(display=none) yaxisopts=(display=none);
proc template;
   define statgraph HeatDendrogram1;
    begingraph;
            layout overlay / walldisplay=none;
               dendrogram nodeID=y_name_ parentID=y_parent_ clusterheight=y_height_;
			 endlayout;
	endgraph;
end;
run;
proc print;run;
proc sgrender data=x template=HeatDendrogram1;
run;

* Example 1: Select all sub-branches below height cutoff 0.6;
*Print out the data to check the correponding branche matched with the hight cutoff;
%subbranches(data=x, out=x3, height=1, render=YES);
proc print data=x3; title "Subbranches with height < 1"; run;

* Example 2: Select subtree under parent CL2 (and descendants);
%subbranches(data=x, out=x3_parent, parent=CL2, render=YES);
proc print data=x3_parent; title "Subbranches under parent CL2"; run;
*/
