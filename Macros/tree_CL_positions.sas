%macro tree_CL_positions(
data=, 	/*A typical output generated by proc cluster*/
child=child,  /*Equivalent to y_name_ or x_name_ from proc cluster; ensure there is not spaces
included in the elements of this variable!*/
parent=parent, /*Equivalent to y_parent_ or x_parent_ from proc cluster*/ 
hh=hh, /*Equivalent to y_height_ or x_height_ from proc cluster*/
root=CL1, /*the toppest root cluster name CL1, and all braches under it will be searched for leaves;
the macro only works when the root is CL1! Do not use other branch names, such as CL2, or others,
as the macro will fail to obtain the right results!*/
order=ASC, /*Any non-string would be OK, as if provided with the string NAME, the input data
will be sorted by parent and child names, however, SAS generted tree data set is used by 
proc tree or the statement of dendrogram in proc template to draw tree by sorting 
with the modified parent by using numers to represnet them, 
child and height, so please just use default string ASC for SAS generated input data*/ 
outds=CL_Positions, /*An output data set containing ordered leaf names from left to right in the dendrogram
if running with SAS to generate tree using the input data, as well as these positions for the parent notes
using the same order system*/
);
data _tmpdsd_;
set &data;
run;
 %treeorder(data=_tmpdsd_, child=&child, parent=&parent, hh=&hh, root=&root, order=&order, outds=&outds); 
*Now match up these leave names with it is input data set _tmpdsd_;
 proc sql;
 create table _tmpdsd_ as
 select *
 from _tmpdsd_
 natural left join
 &outds(rename=(name=&child))
 ;
data _tmpdsd_(drop=order);
set _tmpdsd_;
if order^=. then &child=trim(left(put(order,best12.)));
run;

*Try to get cluster CL positions;
  %local tmp parents rc;
  data _tree_src;
  set _tmpdsd_;
  *Use numeric parent to order it;
  _parent_=prxchange("s/^CL//",-1,&parent)+0;
  run;
  /* 1) ensure sorted children by chosen order (HH or NAME) */
  %if %upcase(&order)=NAME %then %do;
     proc sort data=_tree_src ; by _parent_ &child; run;
  %end;
  %else %do;
     /* order by height (hh) then child name */
     proc sort data=_tree_src; by _parent_ &child &hh; run;
  %end;

  /* 2) create a parent -> space-separated children list */
  data _parent_list(keep=&parent children _parent_);
     length children $ 3000;
     retain children;
     set _tree_src;
     by _parent_;
     if first._parent_ then children = strip(&child);
     else children = catx(' ', children, strip(&child));

	 if not prxmatch("/CL/",children) then do;
		  *Get sum of these numeric children and change them back into char;
	      xi=1;
		  yi=0;
	      do while (scan(children,xi,' ') ne '');
			 yi=yi+scan(children,xi,' ');
			 xi+1;
		  end;
		  yi=yi/(xi-1);/*Get the avg pos for all end leaves belonging to the same parent CLnum*/
		  children=trim(left(put(yi,best12.)));
	 end;

     if last._parent_ then output;
  run;
  *Remove these parents do not have any children;
  data _parent_list;
  set _parent_list;
  where children^=".";
  run;
  proc sql noprint;
  select &parent into: removed_parents separated by ' '
  from _parent_list
  where children=".";
  %if %length(&removed_parents)>0 %then %do;
  %put These parents do not have any children, which will be removed from the final data set;
  %put &removed_parents;
  %end;

  *Recursively calcuate the CL positions;
  %let change=1;
  %let tot_runs=1;
  %do %while (&change);
	   proc sql;
	   create table _parents as
	   select children,&parent
	   from _parent_list 
	   where children contains "CL" and &parent contains "CL";

	   create table _children as 
	   select children as &child,&parent
	   from _parent_list 
	   where (children not contains "CL" and &parent contains "CL" and children^=".");
	   *Note: it is necessary to remove children with missing value ".";
	   *These records are actually no-useful notes or leaves that are probably generated by subbranch macro;

	   data _parents;
	   length _child $100.;
	   set _parents;
	   ci=1;
	   do while (scan(trim(left(children)),ci,' ') ^='');
		  _child=scan(trim(left(children)),ci,' ');
		  output;
		  ci+1;
	   end;
	   drop ci;
	   run;

	   proc sql;
	   create table _parent_tmp  as
	   select a.*,input(b.&child,best12.) as &child
	   from _parents as a
	   left join
	   _children as b
	   on a._child=b.&parent;

	   *Rescue the data set when the parent contains "\d+ CL\d+";
	   *Otherwise, there will be no obs remain in the _resolved_children dataset;
	   data _parent_tmp;
	   set _parent_tmp;
	   if &child=. and not prxmatch("/^CL\d+/",_child) then do;
			 &child=_child+0;
	   end;
	   run;

	   proc sql;
	   create table _resolved_children as
	   select distinct &parent,trim(left(put(mean(&child),best12.))) as &child,children
	   from (
             select * from _parent_tmp
             where &child^=.
            )
	   group by &parent
	   having count(&parent)=2 or (_child=children);
	   *When _child and child is the same single branch and no other paired children for any group;
	   *there will be no records in the final dataset _resolved_children and the macro will run forever;
	   *to resolve the issue, add the extra condition _child=children for the single branch that still ca be further averaged;
	   *for downstream analysis;

	   data _children(rename=(&child=children));
	   set _children _resolved_children(keep=&child &parent);
	   run;
	  
	   proc sql;
       create table _parent_left as
       select distinct children,&parent
       from _parent_tmp
       where children not in (
		 select distinct children
		 from _resolved_children
       ); 
	   %let tot_runs=%eval(&&tot_runs+1);
	   %if &sqlobs=0 %then %do;
	      %let change=0;
		%end;

		data _parent_list;
		set _children _parent_left;
		run;
	  %if &tot_runs>100 %then %do;
		%put It ran 100 times but is still not converged;
		%put Please check the following 4 data sets for debugging:;
		%put _parents, _children, _parent_tmp, and _resolved_childre;
        %abort 255; 
	  %end;
  %end;

  *Add _parent_list into the leaf name data set;
  data 	_parent_list;
  set _parent_list;
  order=children+0;
  drop children;
  run;
  data &outds;
  set &outds _parent_list(rename=(&parent=name));
  run;
  
%mend tree_CL_positions;

/*Demo codes:;
data a;
input child1 :$200. parent1 :$200. hh;
cards;
NG_MYH11__CBFB	CL7	0
NTU_MYH11__CBFB	CL7	0
NG_KMT2Ar	CL6	0
NTU_KMT2Ar	CL6	0
NG_APL	CL5	0
NTU_APL	CL5	0
NG_RUNX1__RUNX1T1	CL4	0
NTU_RUNX1__RUNX1T1	CL4	0
CL5	CL3	0.48486
CL6	CL3	0.36378
CL3	CL2	0.90933
CL4	CL2	0.50744
CL2	CL1	1.12322
CL7	CL1	0.25102
CL1	 .	1.60468
;

proc template;
   define statgraph HeatDendrogram1;
    begingraph;
            layout overlay / walldisplay=none;
               dendrogram nodeID=child1 parentID=parent1 clusterheight=hh;
			 endlayout;
	endgraph;
end;
run;
proc print;run;
proc sgrender data=a template=HeatDendrogram1;
run;

%tree_CL_positions(
data=a, 	
child=child1, 
parent=parent1, 
hh=hh, 
root=CL1, 
order=ASC, 
outds=CL_Positions
);


*/
